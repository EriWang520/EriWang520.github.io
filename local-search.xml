<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java知识点-深拷贝和浅拷贝</title>
    <link href="/2020/12/30/Java%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2020/12/30/Java%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="Java知识点-深拷贝和浅拷贝"><a href="#Java知识点-深拷贝和浅拷贝" class="headerlink" title="Java知识点-深拷贝和浅拷贝"></a>Java知识点-深拷贝和浅拷贝</h1><h3 id="1-克隆"><a href="#1-克隆" class="headerlink" title="1.克隆"></a>1.<em>克隆</em></h3><p>在实际编程过程中，我们常常要遇到这种情况：</p><p>有一个对象A，在某一时刻A中已经包含了一些有效值，此时可能 会需要一个和A完全相同新对象B，并且此后对B任何改动都不会影响到A中的值，也就是说，A与B是两个独立的对象，但B的初始值是由A对象确定的。在 Java语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需求虽然有很多途径，但实现clone（）方法是其中最简单，也是最高效的手段。 </p><p>Java的所有类都默认继承java.lang.Object类，在java.lang.Object类中有一个方法clone()。JDK API的说明文档解释这个方法将返回Object对象的一个拷贝。</p><p>要说明的有两点：一是拷贝对象返回的是一个新对象，而不是一个引用。二是拷贝对象与用 new操作符返回的新对象的区别就是这个拷贝已经包含了一些原来对象的信息，而不是对象的初始信息。</p><h3 id="2-深拷贝与浅拷贝"><a href="#2-深拷贝与浅拷贝" class="headerlink" title="2.深拷贝与浅拷贝"></a>2.<em>深拷贝与浅拷贝</em></h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。</p><p>举例来说更加清楚：对象A1中包含对B1的引用，B1中包含对C1的引用。</p><p>浅拷贝A1得到A2，A2 中依然包含对B1的引用，B1中依然包含对C1的引用。</p><p>深拷贝则是对浅拷贝的递归，深拷贝A1得到A2，A2中包含对B2（B1的copy）的引用，B2 中包含对C2（C1的copy）的引用。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树和平衡二叉树</title>
    <link href="/2020/12/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/12/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树和平衡二叉树"><a href="#二叉搜索树和平衡二叉树" class="headerlink" title="二叉搜索树和平衡二叉树"></a>二叉搜索树和平衡二叉树</h1><p>虽然之前看过二叉树的，但是时间久了还是容易模糊，所以这里继续记录一下。而且主要是看到一篇非常形象好理解的博客，所以这里转载一下，自己做个保存。</p><p>原文链接：<a href="https://blog.csdn.net/qq_25940921/article/details/82183093">https://blog.csdn.net/qq_25940921/article/details/82183093</a></p><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>　　二叉查找树，也称二叉搜索树，或二叉排序树。其定义也比较简单，要么是一颗空树，要么就是具有如下性质的二叉树：</p><p>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>（2） 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>（3） 任意节点的左、右子树也分别为二叉查找树；</p><p>（4） 没有键值相等的节点。</p><p><img src="https://i.loli.net/2020/12/05/KFnUASyHam9idBe.png" alt="image-20201205163840578"></p><p>如上图所示，是不同形态的二叉查找树。二叉查找树是对要查找的数据进行生成树，左支的值小于右支的值。在查找的时候也是一样的思路，从根节点开始，比节点大进入右支，比节点小进入左支，直到查找到目标值。</p><p>　　二叉查找树的插入算法比较简单：空树，就首先生成根节点；不是空树就按照查找的算法，找到父节点，然后作为叶子节点插入，如果值已经存在就插入失败。</p><p>　　删除操作稍微复杂一点，有如下几种情况：</p><p> （1）如果删除的是叶节点，可以直接删除；</p><p> （2）如果被删除的元素有一个子节点，可以将子节点直接移到被删除元素的位置；</p><p> （3）如果有两个子节点，这时候就采用中序遍历，找到待删除的节点的后继节点，将其与待删除的节点互换，此时待删除节点的位置已经是叶子节点，可以直接删除。如下图：</p><p><img src="https://i.loli.net/2020/12/05/mqac19Lg5nQVIOD.png" alt="image-20201205164030082"></p><p>将待删除节点与后继节点互换，变成如下图所示：</p><p><img src="https://i.loli.net/2020/12/05/Y6lyC4A2aveMD5Q.png" alt="image-20201205165616516"></p><p>将待删除元素删除，如下图所示：</p><p><img src="https://i.loli.net/2020/12/05/CbRF1gywjDhGNrm.png" alt="image-20201205165647271"></p><p>另外，二叉查找树还有一个性质，即<strong>对二叉查找树进行中序遍历，即可得到有序的数列。</strong></p><p>　　二叉查找树的查询复杂度，和二分查找一样，插入和查找的时间复杂度均为 O(logn) ，但是在最坏的情况下仍然会有 O(n) 的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（如上不同形态的二叉树图中的b）。</p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>　　平衡二叉搜索树，又被称为AVL树，且具有以下性质：<strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong> —-来自百度百科</p><p>　　由于普通的二叉查找树会容易失去”平衡“，极端情况下，二叉查找树会退化成线性的链表，导致插入和查找的复杂度下降到 O(n) ，所以，这也是平衡二叉树设计的初衷。那么平衡二叉树如何保持”平衡“呢？根据定义，有两个重点，一是左右两子树的高度差的绝对值不能超过1，二是左右两子树也是一颗平衡二叉树。</p><p>　　如下图所示，左图是一棵平衡二叉树，根节点10，左右两子树的高度差是1，而右图，虽然根节点左右两子树高度差是0，但是右子树15的左右子树高度差为2，不符合定义，所以右图不是一棵平衡二叉树。</p><p><img src="https://i.loli.net/2020/12/05/EmVkD6l4MxeCAIH.png" alt="image-20201205165758268"></p><p>由此可以看出平衡二叉树是一棵高度平衡的二叉查找树。所以，要构建跟维系一棵平衡二叉树就比普通的二叉树要复杂的多。在构建一棵平衡二叉树的过程中，当有新的节点要插入时，检查是否因插入后而破坏了树的平衡，如果是，则需要做旋转去改变树的结构。</p><p>　　关于旋转，这东西不拿动态图将还真很难讲明白。所以我就借一下 <a href="https://blog.csdn.net/sun_tttt/article/details/65445754">最容易懂得红黑树</a> 这篇文章中左旋右旋的图来讲。</p><p> <strong>左旋</strong>：</p><p><img src="https://i.loli.net/2020/12/05/HtmRgJGCSq4Mkjz.gif" alt="左旋"></p><p><strong>右旋</strong>：</p><p><img src="https://i.loli.net/2020/12/05/RJaT1LlOso9xGrc.gif" alt="右旋"></p><p>不同于顺时针跟逆时针变换这种方式去记忆，上面两个动态图特别方便记忆跟理解：</p><p>　　<strong>左旋就是将节点的右支往左拉，右子节点变成父节点，并把晋升之后多余的左子节点出让给降级节点的右子节点；</strong></p><p>　　<strong>而右旋就是反过来，将节点的左支往右拉，左子节点变成了父节点，并把晋升之后多余的右子节点出让给降级节点的左子节点。</strong></p><p>　　<strong>即左旋就是往左变换，右旋就是往右变换。</strong>不管是左旋还是右旋，旋转的目的都是<strong>将节点多的一支出让节点给另一个节点少的一支</strong>。</p><p>　　举个例子，像上图是否平衡二叉树的图里面，左图在没插入前”19“节点前，该树还是平衡二叉树，但是在插入”19“后，导致了”15“的左右子树失去了”平衡“，所以此时可以将”15“节点进行左旋，让”15“自身把节点出让给”17“作为”17“的左树，使得”17“节点左右子树平衡，而”15“节点没有子树，左右也平衡了。如下图，</p><p><img src="https://i.loli.net/2020/12/05/DTqPaSQ4frCXJyN.png" alt="image-20201205170026045"></p><p>由于在构建平衡二叉树的时候，当有<strong>新节点插入</strong>时，都会判断插入后时候平衡，这说明了插入新节点前，都是平衡的，也即高度差绝对值不会超过1。当新节点插入后，有可能会有导致树不平衡，这时候就需要进行调整，而可能出现的情况就有4种，分别称作<strong>左左，左右，右左，右右</strong>。</p><p><strong>左左</strong>：</p><p><img src="https://i.loli.net/2020/12/05/6g1y7xAHQutwqk4.png" alt="image-20201205170102008"></p><p>左左即为在原来平衡的二叉树上，在节点的左子树的左子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”10“节点的左子树”7“，的左子树”4“，插入了节点”5“或”3“导致失衡。</p><p>　　左左调整其实比较简单，只需要对节点进行右旋即可，如下图，对节点”10“进行右旋，</p><p>　　注意：如果对左右旋变换还不是很懂或不是很熟练的，可以对照着前面的那两个动图去想象，自己动手变换几次，就明白了。</p><p><img src="https://i.loli.net/2020/12/05/ohVw9Znm4xlbStN.png" alt="image-20201205170211537"></p><p><strong>左右</strong>：</p><p><img src="https://i.loli.net/2020/12/05/9BYk6CqoFsriyh7.png" alt="image-20201205170256122"></p><p>左右即为在原来平衡的二叉树上，在节点的左子树的右子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”11“节点的左子树”7“，的右子树”9“，插入了节点”10“或”8“导致失衡。</p><p>　　左右的调整就不能像左左一样，进行一次旋转就完成调整。我们不妨先试着让左右像左左一样对”11“节点进行右旋，结果图如下，右图的二叉树依然不平衡，而右图就是接下来要讲的右左，即左右跟右左互为镜像，左左跟右右也互为镜像。</p><p><img src="https://i.loli.net/2020/12/05/CcseN1OY3GHkuaL.png" alt="image-20201205170343470"></p><p><strong>右右跟左左一样，只需要旋转一次就能把树调整平衡，而左右跟右左也一样，都要进行旋转两次才能把树调整平衡</strong>，所以，首先上图的这种调整是错误的，正确的调整方式是，将左右进行第一次旋转，将左右先调整成左左，然后再对左左进行调整，从而使得二叉树平衡。</p><p>　　即先对上图的节点”7“进行左旋，使得二叉树变成了左左，之后再对”11“节点进行右旋，此时二叉树就调整完成，如下图，</p><p><img src="https://i.loli.net/2020/12/05/DSsq3UgfRcAVbj5.png" alt="image-20201205170418373"></p><p><strong>右左</strong>：</p><p><img src="https://i.loli.net/2020/12/05/9Bl1xXWQasONyeu.png" alt="image-20201205170456817"></p><p>右左即为在原来平衡的二叉树上，在节点的右子树的左子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”11“节点的右子树”15“，的左子树”13“，插入了节点”12“或”14“导致失衡。</p><p>　　前面也说了，右左跟左右其实互为镜像，所以调整过程就反过来，先对节点”15“进行右旋，使得二叉树变成右右，之后再对”11“节点进行左旋，此时二叉树就调整完成，如下图，</p><p><img src="https://i.loli.net/2020/12/05/5jixoMl3efBb7nW.png" alt="image-20201205170522548"></p><p><strong>右右</strong>：</p><p><img src="https://i.loli.net/2020/12/05/hHfPa9wKxGRSYnm.png" alt="image-20201205170559188"></p><p>右右即为在原来平衡的二叉树上，在节点的右子树的右子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”11“节点的右子树”13“，的左子树”15“，插入了节点”14“或”19“导致失衡。</p><p>　　右右只需对节点进行一次左旋即可调整平衡，如下图，对”11“节点进行左旋。</p><p><img src="https://i.loli.net/2020/12/05/eTaNyrdnDUIqt5Q.png" alt="image-20201205170632008"></p><p>平衡二叉树构建的过程，就是节点插入的过程，插入失衡情况就上面4种，算简单了，下面讲下<strong>平衡二叉树节点的删除</strong>，删除的情况会复杂一点，复杂的原因主要在于删除了节点之后要维系二叉树的平衡，但是删除二叉树节点总结起来就两个判断：<strong>①删除的是什么类型的节点？②删除了节点之后是否导致失衡？</strong></p><p>　　节点的类型有三种：1.叶子节点；2.只有左子树或只有右子树；3.既有左子树又有右子树。</p><p>　　针对这三种节点类型，再引入判断②，所以<strong>处理思路</strong>分别是：</p><p>（1）当删除的节点是叶子节点，则将节点删除，然后从父节点开始，判断是否失衡，如果没有失衡，则再判断父节点的父节点是否失衡，直到根节点，此时到根节点还发现没有失衡，则说此时树是平衡的；如果中间过程发现失衡，则判断属于哪种类型的失衡（左左，左右，右左，右右），然后进行调整。</p><p>（2）删除的节点只有左子树或只有右子树，这种情况其实就比删除叶子节点的步骤多一步，就是将节点删除，然后把仅有一支的左子树或右子树替代原有结点的位置，后面的步骤就一样了，从父节点开始，判断是否失衡，如果没有失衡，则再判断父节点的父节点是否失衡，直到根节点，如果中间过程发现失衡，则根据失衡的类型进行调整。</p><p>（3）删除的节点既有左子树又有右子树，这种情况又比上面这种多一步，就是中序遍历，找到待删除节点的前驱或者后驱都行，然后与待删除节点互换位置，然后把待删除的节点删掉，后面的步骤也是一样，判断是否失衡，然后根据失衡类型进行调整。</p><p>　　最后总结一下，平衡二叉树是一棵高度平衡的二叉树，所以<strong>查询的时间复杂度是 O(logN)</strong> 。<strong>插入</strong>的话上面也说，失衡的情况有4种，左左，左右，右左，右右，即一旦插入新节点导致失衡需要调整，<strong>最多也只要旋转2次</strong>，所以，<strong>插入复杂度是 O(1)</strong> ，但是平衡二叉树也不是完美的，也有<strong>缺点</strong>，从上面删除处理思路中也可以看到，就是<strong>删除节点时有可能因为失衡，导致需要从删除节点的父节点开始，不断的回溯到根节点，如果这棵平衡二叉树很高的话，那中间就要判断很多个节点</strong>。所以后来也出现了综合性能比其更好的树—-<strong>红黑树</strong>，后面再讲。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA快捷键-Windows</title>
    <link href="/2020/12/02/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE-Windows/"/>
    <url>/2020/12/02/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE-Windows/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA快捷键-Windows"><a href="#IDEA快捷键-Windows" class="headerlink" title="IDEA快捷键-Windows"></a>IDEA快捷键-Windows</h1><h2 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h2><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + F</td><td>在当前文件进行文本查找 <code>（必备）</code></td></tr><tr><td>Ctrl + R</td><td>在当前文件进行文本替换 <code>（必备）</code></td></tr><tr><td>Ctrl + Z</td><td>撤销 <code>（必备）</code></td></tr><tr><td>Ctrl + Y</td><td>删除光标所在行 或 删除选中的行 <code>（必备）</code></td></tr><tr><td>Ctrl + X</td><td>剪切光标所在行 或 剪切选择内容</td></tr><tr><td>Ctrl + C</td><td>复制光标所在行 或 复制选择内容</td></tr><tr><td>Ctrl + D</td><td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td></tr><tr><td>Ctrl + W</td><td>递进式选择代码块。选中光标所在的单词或段落，连续按可在选中基础上扩展选中范围 <code>（必备）</code></td></tr><tr><td>Ctrl + E</td><td>显示最近打开的文件记录列表</td></tr><tr><td>Ctrl + N</td><td>根据输入的 <strong>类名</strong> 查找类文件</td></tr><tr><td>Ctrl + G</td><td>在当前文件跳转到指定行处</td></tr><tr><td>Ctrl + J</td><td>插入自定义动态代码模板</td></tr><tr><td>Ctrl + P</td><td>方法参数提示显示</td></tr><tr><td>Ctrl + Q</td><td>光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td></tr><tr><td>Ctrl + U</td><td>前往当前光标所在的方法的父类的方法 / 接口定义</td></tr><tr><td>Ctrl + B</td><td>进入光标所在的方法/变量的接口或是定义出，等效于 <code>Ctrl + 左键单击</code></td></tr><tr><td>Ctrl + K</td><td>版本控制提交项目，需要此项目有加入到版本控制才可用</td></tr><tr><td>Ctrl + T</td><td>版本控制更新项目，需要此项目有加入到版本控制才可用</td></tr><tr><td>Ctrl + H</td><td>显示当前类的层次结构</td></tr><tr><td>Ctrl + O</td><td>选择可重写的方法</td></tr><tr><td>Ctrl + I</td><td>选择可继承的方法</td></tr><tr><td>Ctrl + +</td><td>展开代码</td></tr><tr><td>Ctrl + -</td><td>折叠代码</td></tr><tr><td>Ctrl + /</td><td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td></tr><tr><td>Ctrl + [</td><td>移动光标到当前所在代码的花括号开始位置</td></tr><tr><td>Ctrl + ]</td><td>移动光标到当前所在代码的花括号结束位置</td></tr><tr><td>Ctrl + F1</td><td>在光标所在的错误代码出显示错误信息</td></tr><tr><td>Ctrl + F3</td><td>调转到所选中的词的下一个引用位置</td></tr><tr><td>Ctrl + F4</td><td>关闭当前编辑文件</td></tr><tr><td>Ctrl + F8</td><td>在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td></tr><tr><td>Ctrl + F9</td><td>执行 Make Project 操作</td></tr><tr><td>Ctrl + F11</td><td>选中文件 / 文件夹，使用助记符设定 / 取消书签</td></tr><tr><td>Ctrl + F12</td><td>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td>Ctrl + Tab</td><td>编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td></tr><tr><td>Ctrl + Enter</td><td>智能分隔行</td></tr><tr><td>Ctrl + End</td><td>跳到文件尾</td></tr><tr><td>Ctrl + Home</td><td>跳到文件头</td></tr><tr><td>Ctrl + Space</td><td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code> <code>（必备）</code></td></tr><tr><td>Ctrl + Delete</td><td>删除光标后面的单词或是中文句</td></tr><tr><td>Ctrl + BackSpace</td><td>删除光标前面的单词或是中文句</td></tr><tr><td>Ctrl + 1,2,3…9</td><td>定位到对应数值的书签位置</td></tr><tr><td>Ctrl + 左键单击</td><td>在打开的文件标题上，弹出该文件路径</td></tr><tr><td>Ctrl + 光标定位</td><td>按 Ctrl 不要松开，会显示光标所在的类信息摘要</td></tr><tr><td>Ctrl + 左方向键</td><td>光标跳转到当前单词 / 中文句的左侧开头位置</td></tr><tr><td>Ctrl + 右方向键</td><td>光标跳转到当前单词 / 中文句的右侧开头位置</td></tr><tr><td>Ctrl + 前方向键</td><td>等效于鼠标滚轮向前效果</td></tr><tr><td>Ctrl + 后方向键</td><td>等效于鼠标滚轮向后效果</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>小技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10 Anaconda环境pythona安装配置chromedriver</title>
    <link href="/2020/11/27/win10%20Anaconda%E7%8E%AF%E5%A2%83pythona%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEchromedriver/"/>
    <url>/2020/11/27/win10%20Anaconda%E7%8E%AF%E5%A2%83pythona%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEchromedriver/</url>
    
    <content type="html"><![CDATA[<h1 id="win10-Anaconda环境pythona安装配置chromedriver"><a href="#win10-Anaconda环境pythona安装配置chromedriver" class="headerlink" title="win10 Anaconda环境pythona安装配置chromedriver"></a>win10 Anaconda环境pythona安装配置chromedriver</h1><p>​        因为之前写爬虫的时候遇到个坑，跟chromedriver有关，但是搜索错误的话完全搜索不到，后面自己找到的问题，在这记录一下。</p><h2 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h2><p>一开始我一直以为Anaconda里是有chromedriver的，这也就导致问题。写完代码后直接报错：</p><pre><code class="hljs python">hp, ht, pid, tid = _winapi.CreateProcess(executable, args, PermissionError:[WinError <span class="hljs-number">5</span>] Acess denied</code></pre><p>或者：</p><pre><code class="hljs python">hp, ht, pid, tid = _winapi.CreateProcess(executable, args, PermissionError:[WinError <span class="hljs-number">5</span>]拒绝访问</code></pre><p>都是一个意思。</p><p>然后百度找了很多，都是说python权限不够，给它加完全控制的权限，结果加了还是不行，一番搜索无果后突然搜到一篇怎么安装chromedriver的博客，我就想到不会是根本没有玩意儿吧。。。</p><h2 id="2、下载chromedriver"><a href="#2、下载chromedriver" class="headerlink" title="2、下载chromedriver"></a>2、下载chromedriver</h2><p>于是我去下载了和我chrome浏览器版本一致的chromedriver,但是观望那个进得去，下载页面却进不去。。。</p><p>然后又找到另一个资源的地址，进去也是打不开下载链接，好不容易进了资源页面，下载不了，然后用迅雷给下下来了，不得不说有时候迅雷有奇效。</p><p>后面找到两个地址：</p><p><em><a href="http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a></em></p><p><a href="https://npm.taobao.org/mirrors/chromedriver/">https://npm.taobao.org/mirrors/chromedriver/</a></p><p>第一个就是谷歌的，应该直接进是进不去的，第二个是淘宝的镜像地址，应该可以下，不过因为我之前是用迅雷下的，所以还没试过第二个地址有没有问题。</p><h2 id="3、配置chromedriver"><a href="#3、配置chromedriver" class="headerlink" title="3、配置chromedriver"></a>3、配置chromedriver</h2><p>下载好之后，还需要配置一下。</p><p>1、把下载的文件解压到谷歌浏览器安装目录的根目录</p><p>如果装在C盘的一般是：</p><p>C:\Users\mi\AppData\Local\Google\Chrome\Application</p><p>直接在桌面右键谷歌浏览器图标就可以进入。不过我改到D盘了。</p><p>2、然后把这个路径添加到环境变量。</p><p><img src="https://i.loli.net/2020/11/27/xhOclNfvP5dwtzR.png" alt="image-20201127100555202"></p><p>3、把解压出来的chromedriver复制一份到Anaconda3根目录就可以了，接着在代码中导入selenium然后就可以直接使用:</p><pre><code class="hljs python">browser = webdriver.Chrome(options=chrome_options)</code></pre><p>获取到chromdriver</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>采坑日记</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令</title>
    <link href="/2020/11/24/Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/11/24/Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="一、文件、目录操作命令"><a href="#一、文件、目录操作命令" class="headerlink" title="一、文件、目录操作命令"></a>一、文件、目录操作命令</h2><h4 id="1、ls命令"><a href="#1、ls命令" class="headerlink" title="1、ls命令"></a>1、ls命令</h4><p>功能：显示文件和目录的信息<br>ls　以默认方式显示当前目录文件列表<br>ls -a 显示所有文件包括隐藏文件<br>ls -l 显示文件属性，包括大小，日期，符号连接，是否可读写及是否可执行<br>ls -lh 显示文件的大小，以容易理解的格式印出文件大小 (例如 1K 234M 2G)<br>ls -lt 显示文件，按照修改时间排序<br> ls -F 在列出的文件名和目录名后添加标志。例如，在可执行文件后添加“*”，在目录名后添加“/”以区分不同的类型。</p><h4 id="2、cd命令"><a href="#2、cd命令" class="headerlink" title="2、cd命令"></a>2、cd命令</h4><p>功能：进入目录<br>cd dir　切换到当前目录下的dir目录<br>cd /　切换到根目录<br>cd ..　切换到到上一级目录<br>cd ../..　切换到上二级目录<br>cd ~　切换到用户目录，比如是root用户，则切换到/root下</p><h4 id="3、cp命令"><a href="#3、cp命令" class="headerlink" title="3、cp命令"></a>3、cp命令</h4><p>功能：copy文件<br>cp source target　将文件source复制为target<br>cp /root /source .　将/root下的文件source复制到当前目录<br>cp –av soure_dir target_dir　将整个目录复制，两目录完全一样</p><h4 id="4、rm命令"><a href="#4、rm命令" class="headerlink" title="4、rm命令"></a>4、rm命令</h4><p>功能：删除文件或目录<br>rm file　删除某一个文件<br>rm -f file 删除时候不进行提示。可以于r参数（递归删除）配合使用<br>rm -rf dir　删除当前目录下叫dir的整个目录</p><h4 id="5、mv命令"><a href="#5、mv命令" class="headerlink" title="5、mv命令"></a>5、mv命令</h4><p>功能：将文件移动走，或者改名，在uinx下面没有改名的命令，如果想改名，可以使用该命令<br>mv source target　将文件source更名为target</p><h4 id="6、diff"><a href="#6、diff" class="headerlink" title="6、diff"></a>6、diff</h4><p>功能：比较文件内容<br>diff dir1 dir2　比较目录1与目录2的文件列表是否相同，但不比较文件的实际内容，不同则列出<br>diff file1 file2　比较文件1与文件2的内容是否相同，如果是文本格式的文件，则将不相同的内容显示，如果是二进制代码则只表示两个文件是不同的<br>comm file1 file2　比较文件，显示两个文件不相同的内容</p><h4 id="7、ln命令"><a href="#7、ln命令" class="headerlink" title="7、ln命令"></a>7、ln命令</h4><p>功能：建立链接。windows的快捷方式就是根据*inx下的链接的原理来做的<br>ln source_path target_path 硬连接<br>ln -s source_path target_path 软连接</p><h2 id="二、查看文件内容命令"><a href="#二、查看文件内容命令" class="headerlink" title="二、查看文件内容命令"></a>二、查看文件内容命令</h2><h4 id="1、cat命令"><a href="#1、cat命令" class="headerlink" title="1、cat命令"></a>1、cat命令</h4><p>显示文件的内容，和DOS的type相同<br>cat file</p><h4 id="2、more命令"><a href="#2、more命令" class="headerlink" title="2、more命令"></a>2、more命令</h4><p>功能：分页显示命令<br>more　file<br>more命令也可以通过管道符(|)与其他的命令一起使用,例如：<br>ps ux|more<br>ls|more</p><h4 id="3、tail-命令"><a href="#3、tail-命令" class="headerlink" title="3、tail 命令"></a>3、tail 命令</h4><p>功能：显示文件的最后几行<br>tail -n 100 aaa.txt  显示文件aaa.txt文件的最后100行<br>tail -f /var/log/messages  使tail不停地去读最新的内容，这样有实时监视的效果</p><h4 id="4、vi命令"><a href="#4、vi命令" class="headerlink" title="4、vi命令"></a>4、vi命令</h4><p>vi file　编辑文件file<br>vi 原基本使用及命令：<br>在命令模式下，按一下”a”（”A”）键或者”i” （”I”）或者”o”（”O”）键，即进入插入态文本输入模式。在文本输入模式下，按Esc键，即回到命令模式。</p><p>  按”a”键，插入到当前光标的后面；按”i”键，在当前光标处插入；按”A”键，在当前光 标所在行的最后插入；按”I”键，在当前光标所在行的开头插入。</p><p> 退出Vi 的方式: 先按[ESC]键回到命令模式，然后输入:w(写入文件),:w!(不询问方式写入文件）,:wq保存并退出,:q退出,q!不保存退出,：x 该命令的功能同命令模式下的ZZ命令功能相同</p><p>在命令模式中，连按两次大写字母Z，若当前编辑的文件曾被修改过，则Vi保存该文件后退出，返回到shell；若当前编辑的文件没被修改过，则Vi直接退出, 返回到shell。</p><h4 id="5、touch命令"><a href="#5、touch命令" class="headerlink" title="5、touch命令"></a>5、touch命令</h4><p>功能：创建一个空文件<br>touch aaa.txt  创建一个空文件，文件名为aaa.txt</p><h2 id="三、基本系统命令"><a href="#三、基本系统命令" class="headerlink" title="三、基本系统命令"></a>三、基本系统命令</h2><h4 id="1、man命令"><a href="#1、man命令" class="headerlink" title="1、man命令"></a>1、man命令</h4><p>功能：查看某个命令的帮助，如果你不知道某个命令的用法不懂，可以问他，他知道就回告诉你<br>例如：<br>man ls 显示ls命令的帮助内容</p><h4 id="2、w命令"><a href="#2、w命令" class="headerlink" title="2、w命令"></a>2、w命令</h4><p>功能：显示登录用户的详细信息<br>例如：<br>[liujl@signal ~]$ w<br>16:51:13 up  4:20,  1 user,  load average: 0.00, 0.00, 0.00<br>USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT<br> root     pts/0    192.168.56.1     12:31    0.00s  0.11s  0.00s w</p><h4 id="3、who命令"><a href="#3、who命令" class="headerlink" title="3、who命令 　　"></a>3、who命令 　　</h4><p>功能：显示登录用户<br>例如：<br>[root@signal u01]# who<br>root     pts/0        2016-03-21 12:31 (192.168.56.1)</p><h4 id="4、last命令"><a href="#4、last命令" class="headerlink" title="4、last命令"></a>4、last命令</h4><p>功能：查看最近那些用户登录系统</p><p>例如：</p><pre><code><pre><code class="hljs shell">[root@signal u01]# last   root     pts/0        192.168.56.1     Mon Mar 21 12:31   still logged in      reboot   system boot  2.6.32-358.el6.x Mon Mar 21 12:31 - 16:53  (04:21)       root     pts/0        192.168.56.1     Mon Feb  1 17:15 - down   (04:29)       reboot   system boot  2.6.32-358.el6.x Mon Feb  1 17:14 - 21:44  (04:30)       root     pts/0        192.168.56.1     Mon Jan 25 18:46 - down   (00:00)       root     pts/0        192.168.56.1     Mon Jan 25 09:24 - 18:46  (09:22)       reboot   system boot  2.6.32-358.el6.x Mon Jan 25 08:53 - 18:46  (09:53)       reboot   system boot  2.6.32-358.el6.x Fri Jan 22 17:58 - 17:58  (00:00)       root     pts/0        192.168.56.1     Fri Jan 22 10:20 - down   (07:37)       reboot   system boot  2.6.32-358.el6.x Fri Jan 22 09:57 - 17:58  (08:01)       root     pts/2        192.168.56.1     Mon Jan 18 09:23 - down   (06:20)       root     pts/1        192.168.56.1     Mon Jan 18 09:21 - down   (06:23)       root     pts/0        :0.0             Mon Jan 18 09:18 - down   (06:26)       root     tty1         :0               Mon Jan 18 09:18 - down   (06:26)       reboot   system boot  2.6.32-358.el6.x Mon Jan 18 09:17 - 15:44  (06:27)       reboot   system boot  2.6.32-358.el6.x Mon Jan 18 09:15 - 09:17  (00:01)</code></pre>wtmp begins Mon Jan 18 09:15:27 2016</code></pre><h4 id="5、date命令"><a href="#5、date命令" class="headerlink" title="5、date命令"></a>5、date命令</h4><p>功能：系统日期设定<br>date　显示当前日期时间<br>date -s 20:30:30　设置系统时间为20:30:30<br>date -s 2002-3-5　设置系统时期为2003-3-5<br>date -s “060520 06:00:00″　设置系统时期为2006年5月20日6点整。</p><h4 id="6、clock命令"><a href="#6、clock命令" class="headerlink" title="6、clock命令"></a>6、clock命令</h4><p>功能：时钟设置<br>clock –r　对系统Bios中读取时间参数<br>clock –w　将系统时间(如由date设置的时间)写入Bios</p><h4 id="7、uname命令"><a href="#7、uname命令" class="headerlink" title="7、uname命令"></a>7、uname命令</h4><p>功能：查看系统版本<br>uname -R　显示操作系统内核的version<br>例如：<br>[root@signal u01]# uname -a<br>Linux signal 2.6.32-358.el6.x86_64 #1 SMP Tue Jan 29 11:47:41 EST 2013 x86_64 x86_64 x86_64 GNU/Linux</p><h4 id="8、关闭和重新启动系统命令"><a href="#8、关闭和重新启动系统命令" class="headerlink" title="8、关闭和重新启动系统命令"></a>8、关闭和重新启动系统命令</h4><p>reboot　  重新启动计算机<br>shutdown -r now  重新启动计算机，停止服务后重新启动计算机<br>shutdown -h now  关闭计算机，停止服务后再关闭系统<br>halt   关闭计算机<br>一般用shutdown -r now,在重启系统是，关闭相关服务，shutdown -h now也是如此。</p><h4 id="9、su命令"><a href="#9、su命令" class="headerlink" title="9、su命令"></a>9、su命令</h4><p>功能：切换用户<br>su -  切换到root用户</p><p>su – liujl 切换到liujl用户，<br>注意：- ，他很关键，使用-，将使用用户的环境变量</p><h2 id="四、监视系统状态命令"><a href="#四、监视系统状态命令" class="headerlink" title="四、监视系统状态命令"></a>四、监视系统状态命令</h2><h4 id="1、top命令"><a href="#1、top命令" class="headerlink" title="1、top命令"></a>1、top命令</h4><p>功能：实时显示系统中各个进程的资源占用状况</p><h4 id="2、free命令"><a href="#2、free命令" class="headerlink" title="2、free命令"></a>2、free命令</h4><p>功能：查看内存和swap分区使用情况<br>例如：<br>[root@signal u01]# free -m<br>                 total       used       free     shared    buffers     cached<br>Mem:          1878        543       1335          0         54        285<br>    -/+ buffers/cache:        203       1675<br> Swap:         2047          0       2047</p><h4 id="3、uptime"><a href="#3、uptime" class="headerlink" title="3、uptime"></a>3、uptime</h4><p>功能：现在的时间 ，系统开机运转到现在经过的时间，连线的使用者数量，最近一分钟，五分钟和十五分钟的系统负载<br>例如：</p><pre><code class="hljs shell">[root@signal u01]# uptime16:56:04 up  4:24,  1 user,  load average: 0.00, 0.00, 0.00</code></pre><h4 id="4、vmstat命令"><a href="#4、vmstat命令" class="headerlink" title="4、vmstat命令"></a>4、vmstat命令</h4><p>功能：监视虚拟内存使用情况<br>例如：<br>[root@signal u01]# vmstat<br>procs ———–memory———- —swap– —–io—- –system– —–cpu—–<br>r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st<br> 0  0      0 1367156  55808 292620    0    0    22     3   12   13  0  0 98  1  0</p><h4 id="5、ps命令"><a href="#5、ps命令" class="headerlink" title="5、ps命令"></a>5、ps命令</h4><p>功能：显示进程信息<br>ps ux 显示当前用户的进程<br>ps uxwww 显示当前用户的进程的详细信息<br>ps aux 显示所有用户的进程<br>ps ef 显示系统所有进程信息</p><h4 id="6、kill命令"><a href="#6、kill命令" class="headerlink" title="6、kill命令"></a>6、kill命令</h4><p>功能：干掉某个进程，进程号可以通过ps命令得到<br>kill -9 1001　将进程编号为1001的程序干掉<br>kill all -9 apache　将所有名字为apapche的程序杀死，kill不是万能的，对僵死的程序则无效。<br>kill -STOP [pid]    发送SIGSTOP (17,19,23)停止一个进程，而并不消灭这个进程。<br>kill -CONT [pid]    发送SIGCONT (19,18,25)重新开始一个停止的进程。<br>kill -KILL [pid]    发送SIGKILL (9)强迫进程立即停止，并且不实施清理操作。<br>kill -9 -1   终止你拥有的全部进程。<br>SIGKILL和SIGSTOP信号不能被捕捉、封锁或者忽略，但是，其它的信号可以</p><h2 id="五、磁盘操作命令"><a href="#五、磁盘操作命令" class="headerlink" title="五、磁盘操作命令"></a>五、磁盘操作命令</h2><h4 id="1、df命令"><a href="#1、df命令" class="headerlink" title="1、df命令"></a>1、df命令</h4><p>功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。<br>参数 功能<br>-a 列出全部目录<br>-Ta 列出全部目录，并且显示文件类型<br>-B 显示块信息<br>-i 以i节点列出全部目录<br>-h 按照日常习惯显示（如：1K、100M、20G）<br>-x [filesystype] 不显示[filesystype]<br>例如：<br>[root@signal u01]# df -Th<br>Filesystem    Type    Size  Used Avail Use% Mounted on<br>/dev/sda3     ext4     23G   14G  8.0G  63% /<br>tmpfs        tmpfs    940M   72K  940M   1% /dev/shm<br>/dev/sda1     ext4    194M   32M  153M  18% /boot</p><h4 id="2、du命令"><a href="#2、du命令" class="headerlink" title="2、du命令"></a>2、du命令</h4><p>功能：检测一个目录和（递归地）所有它的子目录中的文件占用的磁盘空间。<br>参数  功能<br>-s [dirName] 显示目录占用总空间<br>-sk [dirName] 显示目录占用总空间，以k为单位<br>-sb [dirName] 显示目录占用总空间，以b为单位<br>-sm [dirName] 显示目录占用总空间，以m为单位<br>-sc [dirName] 显示目录占用总空间，加上目录统计<br>-sh [dirName] 只统计目录大小</p><p>例如：<br>[root@signal u01]# du -sh app<br>5.8G    app</p><h4 id="3、mount命令"><a href="#3、mount命令" class="headerlink" title="3、mount命令"></a>3、mount命令</h4><p>功能：使用mount命令就可在Linux中挂载各种文件系统。<br>格式：mount -t &lt;文件系统&gt; 设备名 挂载点<br>(1)mount /dev/sda1  /mnt/filetest<br>mount -t vfat /dev/hda  /mnt/fatfile<br>mount -t ntfs /dev/hda  /mnt/ntfsfile<br>mount -t iso9660 /dev/cdrom  /mnt/cdrom<br>mount -o &lt;选项&gt; 设备名 挂载点</p><p>(2)使用usb设备<br>modprobe usb-storage<br>mkdir /mnt/usb<br>mount -t auto /dev/sdx1 /mnt/usb<br>umount /mnt/usb</p><h4 id="4、mkswap命令"><a href="#4、mkswap命令" class="headerlink" title="4、mkswap命令"></a>4、mkswap命令</h4><p>功能：使用mkswap命令可以创建swap空间，如：<br>debian:<del># mkswap -c /dev/hda4<br>debian:</del># swapon /dev/hda4      #启用新创建的swap空间，停用可使用swapoff命令</p><h4 id="5、fdisk命令"><a href="#5、fdisk命令" class="headerlink" title="5、fdisk命令"></a>5、fdisk命令</h4><p>功能：对磁盘进行分区<br>fdisk /dev/xxx 格式化xxx设备(xxx是指磁盘驱动器的名字，例如hdb，sdc)<br>fdisk -l 显示磁盘的分区表</p><h4 id="6、mkfs命令"><a href="#6、mkfs命令" class="headerlink" title="6、mkfs命令"></a>6、mkfs命令</h4><p>功能：格式化文件系统，可以指定文件系统的类型，如ext2、ext3、fat、ntfs等<br>格式1：mkfs.ext3 options /dev/xxx<br>格式2：mkfs -t ext2 options /dev/xxx<br>参数   功能<br>-b &lt;1024|2048|4096&gt; 块大小<br>-i <number>  节点大写<br>-m <number>  预留管理空间大小<br>例如：<br>debian:~#mkfs.ext4 /dev/sdb1</p><h4 id="7、e2fsck命令"><a href="#7、e2fsck命令" class="headerlink" title="7、e2fsck命令"></a>7、e2fsck命令</h4><p>功能：磁盘检测<br>e2fsck /dev/hda1　检查/dev/hda1是否有文件系统错误，提示修复方式<br>e2fsck -p /dev/hda1　检查/dev/hda1是否有错误，如果有则自动修复<br>e2fsck -y /dev/hda1　检查错误，所有提问均于yes方式执行<br>e2fsck -c /dev/hda1　检查磁盘是否有坏区</p><h4 id="8、tune2fs命令"><a href="#8、tune2fs命令" class="headerlink" title="8、tune2fs命令"></a>8、tune2fs命令</h4><p>功能：调整ext2/ext3文件的参数<br>参数  功能<br>-l <device> 查看文件系统信息<br>-c <count> 设置强制自检的挂载次数<br>-i <n day> 设置强制自检的间隔时间，单位天<br>-m <percentage> 保留块的百分比<br>-j  将ext2文件系统转换成ext3格式</p><p>tune2fs -l /dev/sda1</p><h4 id="9、dd命令"><a href="#9、dd命令" class="headerlink" title="9、dd命令"></a>9、dd命令</h4><p>功能：把指定的输入文件拷贝到指定的输出文件中，并且在拷贝过程中可以进行格式转换。<br>跟DOS下的diskcopy命令的作用类似。<br>dd if=/dev/fd0 of=floppy.img　将软盘的内容复制成一个镜像<br>dd if=floppy.img of=/dev/fd0　将一个镜像的内容复制到软盘，做驱动盘的时候经常用。</p><h2 id="六、用户和组相关命令"><a href="#六、用户和组相关命令" class="headerlink" title="六、用户和组相关命令"></a>六、用户和组相关命令</h2><h4 id="1、groupadd命令"><a href="#1、groupadd命令" class="headerlink" title="1、groupadd命令"></a>1、groupadd命令</h4><p>　　功能：添加组<br>　　groupadd dba  添加dba组<br>　　groupadd -g 1001 dba  添加dba组，组id为1001</p><h4 id="2、useradd命令"><a href="#2、useradd命令" class="headerlink" title="2、useradd命令"></a>2、useradd命令</h4><p>功能：添加用户<br>　　useradd liujl  添加用户，home为/home/user1，组为user1<br>　　useradd -g dba -m -d /home/liujl liujl 添加用户liujl，home为/home/liujl，组为liujl<br>　　user list　显示已登陆的用户列表</p><h4 id="3、passwd命令"><a href="#3、passwd命令" class="headerlink" title="3、passwd命令"></a>3、passwd命令</h4><p>功能：更改用户密码<br>　　passwd liujl　修改用户user1的密码<br>　　passwd -d root　将root用户的密码删除</p><h4 id="4、userdel命令"><a href="#4、userdel命令" class="headerlink" title="4、userdel命令"></a>4、userdel命令</h4><p>功能：删除用户<br>　　userdel liujl　删除liujl用户</p><h4 id="5、chown命令"><a href="#5、chown命令" class="headerlink" title="5、chown命令"></a>5、chown命令</h4><p>功能：改变文件或目录的所有者<br>　　chown liujl /dir　将/dir目录设置为user1所有<br>　　chown -R liujl:dba /dir　将/dir目录下所有文件和目录，设置为liujl所有,组为dba。-R递归到下面的每个文件和目录</p><h4 id="6、chgrp命令"><a href="#6、chgrp命令" class="headerlink" title="6、chgrp命令"></a>6、chgrp命令</h4><p>功能：改变文件或目录的所有组<br>　　chgrp dba /dir　将/dir目录设置为dba所有</p><h4 id="7、chmod命令"><a href="#7、chmod命令" class="headerlink" title="7、chmod命令"></a>7、chmod命令</h4><p>功能：改变用户的权限<br>　　chmod a+x file　将file文件设置为可执行，脚本类文件一定要这样设置一个，否则得用bash file才能执行<br>　　chmod 666 file　将文件file设置为可读写<br>　　chmod 750 file 将文件file设置为，所有者为完全权限，同组可以读和执行，其他无权限</p><h4 id="8、id命令"><a href="#8、id命令" class="headerlink" title="8、id命令"></a>8、id命令</h4><p>功能：显示用户的信息，包括uid、gid等</p><p>id liujl</p><p>uid=1002(liujl) gid=1002(liujl) groups=1002(liujl)</p><h4 id="9、finger命令"><a href="#9、finger命令" class="headerlink" title="9、finger命令"></a>9、finger命令</h4><p>功能：显示用户的信息<br>注意：debian下没有该命令。</p><p>finger liujl</p><p>　　Login: liujl                           Name:<br>　　Directory: /home/liujl                 Shell: /bin/bash<br>　　On since Mon Mar 21 07:59 (CST) on pts/0 from 192.168.56.10<br>　　No mail.<br>　　No Plan.</p><h2 id="七、压缩命令"><a href="#七、压缩命令" class="headerlink" title="七、压缩命令"></a>七、压缩命令</h2><h4 id="1、gzip格式命令"><a href="#1、gzip格式命令" class="headerlink" title="1、gzip格式命令"></a>1、gzip格式命令</h4><p>功能：压缩文件，gz格式的<br>注意：生成的文件会把源文件覆盖<br>　　gzip -v <filename> 压缩文件，并且显示进度<br>　　-d <filename> 解压缩<br>　　gnuzip  -f <filename> 解压缩<br>例如：</p><p>gzip 1.sh</p><p>　　#ll<br>　　-rw-r–r–. 1 root   root       25 Mar 21 17:10 1.sh.gz</p><h4 id="2、zip格式命令"><a href="#2、zip格式命令" class="headerlink" title="2、zip格式命令"></a>2、zip格式命令</h4><p>功能：压缩和解压缩zip命令<br>zip  <DSTfilename> <SRCfilename><br>unzip  <filename><br>例如：</p><p>zip a.sh.zip a.sh</p><p>adding: a.sh (stored 0%)</p><p>ll</p><p>　　-rw-r–r–    1 root     root          188  5月 21 10:37 a.sh.zip</p><p>unzip a.sh.zip</p><p>Archive:  a.sh.zip<br>replace a.sh? [y]es, [n]o, [A]ll, [N]one, [r]ename: r<br>new name: a1.sh<br>extracting: a1.sh</p><p>ll</p><p>　　-rwxr-xr-x    1 root     root           48 12月 18 21:08 a1.sh</p><h4 id="3、bzip2根式命令"><a href="#3、bzip2根式命令" class="headerlink" title="3、bzip2根式命令"></a>3、bzip2根式命令</h4><p>功能：bzip2格式压缩命令，<br>注意：生成的文件会把源文件覆盖<br>bzip2   <filename><br>bunzip2 <filename><br>例如：</p><p>bzip2 a.sh</p><p>　　# ll<br>　　-rwxr-xr-x    1 root     root           85 12月 18 21:08 a.sh.bz2</p><p>bunzip2 a.sh.bz2</p><p>　　# ll<br>　　-rwxr-xr-x    1 root     root           48 12月 18 21:08 a.sh</p><h4 id="4、tar命令"><a href="#4、tar命令" class="headerlink" title="4、tar命令"></a>4、tar命令</h4><p>功能：归档、压缩等，比较重要，会经常使用。<br>　　-cvf  &lt;DSTfilename.tar&gt; <SRCfilename> 压缩文件或目录<br>　　-xvf  <SRCfilename>   解压缩文件或目录<br>　　-zcvf  <DSTfilename> <SRCfilename> 压缩文件，格式tar.gz<br>　　-zxvf  <DSTfilename> <SRCfilename> 解压缩文件，格式tar.gz<br>　　-zcvf  &lt;DST.tgz&gt; <SRCfilename>  压缩文件，格式tgz<br>　　-zxvf  &lt;DST.tgz&gt; <SRCfilename>  解压缩文件，格式tgz</p><p>tar xzvf abc.tar.gz</p><h2 id="八、网络相关命令"><a href="#八、网络相关命令" class="headerlink" title="八、网络相关命令"></a>八、网络相关命令</h2><h4 id="1、ifconfig命令"><a href="#1、ifconfig命令" class="headerlink" title="1、ifconfig命令"></a>1、ifconfig命令</h4><p>功能：显示修改网卡的信息<br>　　ifconfig  显示网络信息<br>　　ifconfig eth0 显示eth0网络信息<br>修改网络信息：<br>　　ifconfig eth0 192.168.1.1 netmask 255.255.255.0 设置网卡1的地址192.168.1.1，掩码为255.255.255.0<br>　　ifconfig eth0:1 192.168.1.2　   捆绑网卡1的第二个地址为192.168.1.2<br>　　ifconfig eth0:x 192.168.1.n　   捆绑网卡1的第n个地址为192.168.1.n　　</p><h4 id="2、route命令"><a href="#2、route命令" class="headerlink" title="2、route命令"></a>2、route命令</h4><p>功能：显示当前路由设置情况<br>　　route 显示当前路由设置情况，比较慢一般不用。<br>　　route add -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254  添加静态路由<br>　　route del -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254  添加静态路由<br>　　route add default gw 192.168.1.1 metric1　   设置192.168.1.1为默认的路由<br>　　route del default　      将默认的路由删除</p><p>举例：</p><p>route add -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254</p><p>netstat -nr</p><p>　　Kernel IP routing table<br>　　Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface<br>　　192.168.1.0     0.0.0.0         255.255.255.0   U         0 0          0 eth0<br>　　10.0.0.0        192.168.1.254   255.255.0.0     UG        0 0          0 eth0<br>　　169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 eth0<br>　　0.0.0.0         192.168.1.254   0.0.0.0         UG        0 0          0 eth0</p><p>route del -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254</p><p>netstat -nr</p><p>　　Kernel IP routing table<br>　　Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface<br>　　192.168.1.0     0.0.0.0         255.255.255.0   U         0 0          0 eth0<br>　　169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 eth0<br>　　0.0.0.0         192.168.1.254   0.0.0.0         UG        0 0          0 eth0</p><h4 id="3、netstat命令"><a href="#3、netstat命令" class="headerlink" title="3、netstat命令"></a>3、netstat命令</h4><p>功能：显示网络状态<br>　　netstat -an  查看网络端口信息<br>　　netstat -nr 查看路由表信息，比route快多了<br>　　-t: 显示TCP链接信息<br>　　-u: 显示UDP链接信息<br>　　-l: 显示监听状态的端口<br>　　-n: 直接显示ip，不做名称转换<br>　　-p: 显示相应的进程PID以及名称（要root权限）<br>　　如果要查看关于sockets更详细占用信息等，可以使用lsof工具。</p><h4 id="4、启动网络的命令"><a href="#4、启动网络的命令" class="headerlink" title="4、启动网络的命令"></a>4、启动网络的命令</h4><p>redhat族的命令:<br>　　/etc/init.d/network<br>　　debian命令:<br>　　/etc/init.d/networking<br>例如：<br>　　/etc/init.d/network stop 停止网络，<br>　　/etc/init.d/network start 启动网络，</p><h4 id="5、手工修改网络配置"><a href="#5、手工修改网络配置" class="headerlink" title="5、手工修改网络配置"></a>5、手工修改网络配置</h4><p><strong>(1)、debian系统</strong><br>配置文件位置为：/etc/network/interfaces</p><p>The loopback network interface</p><p>　　auto lo<br>　　iface lo inet loopback</p><p>The primary network interface</p><p>　　auto eth0 eth1<br>　　iface eth0 inet static<br>　　address 10.4.5.6<br>　　netmask 255.255.255.0<br>　　network 10.4.5.0<br>　　broadcast 10.4.5.255<br>　　iface eth1 inet static<br>　　address 219.25.5.60<br>　　netmask 255.255.255.192<br>　　network 219.25.5.0<br>　　broadcast 219.25.5.63<br>　　gateway 219.25.5.30<br>　　修改后保存配置后，运行<br>　　/etc/init.d/networking restart<br>　　网络配置就改变了</p><p><strong>(2)、redhat系统</strong><br>　　配置文件位置为：/etc/sysconfig/network-scripts/ifcfg-eth0<br>　　DEVICE=eth0<br>　　BOOTPROTO=static<br>　　BROADCAST=192.168.1.255<br>　　IPADDR=192.168.1.5<br>　　NETMASK=255.255.255.0<br>　　NETWORK=192.168.1.0<br>　　GATEWAY=192.168.1.254<br>　　ONBOOT=yes<br>　　TYPE=Ethernet<br>　　修改后保存配置后，运行<br>　　/etc/init.d/network restart<br>　　或者<br>　　service network restart<br>　　网络配置就改变了。<br>　　默认DNS的文件的位置为：/etc/resolv.conf<br>　　#cat /etc/resolv.conf<br>　　search test.com.cn<br>　　nameserver 192.168.1.11</p><h4 id="6、网络排错"><a href="#6、网络排错" class="headerlink" title="6、网络排错"></a>6、网络排错</h4><p><strong>(1)、ping命令</strong><br>　　功能：不说了，不知道就用干这行了。<br>　　ping <a href="http://www.163.com/">www.163.com</a><br><strong>(2)、traceroute命令</strong></p><p>　　功能：路由跟踪<br>　　traceroute <a href="http://www.163.com/">www.163.com</a><br>　　traceroute 207.68.173.7</p><p><strong>(3)、nslookup命令</strong></p><p>　　功能：域名解析排错<br>　　例如：<br>　　$ nslookup</p><h2 id="九、其他命令"><a href="#九、其他命令" class="headerlink" title="九、其他命令"></a>九、其他命令</h2><h4 id="1、ssh命令"><a href="#1、ssh命令" class="headerlink" title="1、ssh命令"></a>1、ssh命令</h4><p>功能：远程登陆到其他UNIX主机<br>　　ssh -l user1 192.168.1.2 使用用户名user1登陆到192.168.1.2<br>　　ssh <a href="mailto:&#x75;&#115;&#101;&#114;&#x31;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#x36;&#56;&#46;&#x31;&#x2e;&#50;">&#x75;&#115;&#101;&#114;&#x31;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#x36;&#56;&#46;&#x31;&#x2e;&#50;</a>   使用用户名user1登陆到192.168.1.2</p><h4 id="2、scp命令"><a href="#2、scp命令" class="headerlink" title="2、scp命令"></a>2、scp命令</h4><p>功能：安全copy<br>例如：<br>　　scp abc.tar.gz <a href="mailto:&#x75;&#115;&#x65;&#x72;&#x31;&#x40;&#49;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#46;&#49;&#46;&#53;">&#x75;&#115;&#x65;&#x72;&#x31;&#x40;&#49;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#46;&#49;&#46;&#53;</a>:~ 将本地的abc.tar.gz 复制到 192.168.1.5的user1用户的根(/home/user1)下。</p><h4 id="3、telnet命令"><a href="#3、telnet命令" class="headerlink" title="3、telnet命令"></a>3、telnet命令</h4><p>功能：登陆到远程主机<br>例如：</p><p>　　telnet 192.168.1.5</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java知识点-JVM(一)</title>
    <link href="/2020/11/24/Java%E7%9F%A5%E8%AF%86%E7%82%B9-JVM%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/11/24/Java%E7%9F%A5%E8%AF%86%E7%82%B9-JVM%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Java知识点-JVM-一"><a href="#Java知识点-JVM-一" class="headerlink" title="Java知识点-JVM(一)"></a>Java知识点-JVM(一)</h1><h2 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h2><ol><li>程序运行过程</li><li>类的加载过程</li><li>垃圾回收器（JVM垃圾回收机制，四个垃圾回收算法，垃圾回收器的分类和使用场景）</li><li>运行时数据区（虚拟机栈、本地方法栈、程序计数器、方法区、堆）</li><li>JVM调优（常用调优方式和工具，常用参数，）</li></ol><h2 id="一、程序运行过程"><a href="#一、程序运行过程" class="headerlink" title="一、程序运行过程"></a>一、程序运行过程</h2><ol><li>先把java代码编译成字节码，也就是吧.java文件编译成.class文件，这个过程的大致执行流程：java源代码-&gt;词法分析-&gt;语法分析-&gt;语义分析-&gt;字节码生成。其实也就是编译原理的那些东西和流程，其中任何一个节点失败就会造成编译失败。</li><li>把 .class文件放到java虚拟机，这个虚拟机通常指Oracle官方自带的Hotspot JVM；</li><li>java虚拟机使用类加载器（Class Loader）装载class文件。</li><li>类加载完成之后，会进行字节码校验，字节码校验通过之后JVM会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是<strong>解释执行</strong>的，JVM对此作了优化，比如对于Hotspot虚拟机来说，它本身提供了JIT(Just In Time)也就是我们通常说的动态编译，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了<strong>编译执行</strong>。</li></ol><h2 id="二、类的加载过程（和上一点有些重复）"><a href="#二、类的加载过程（和上一点有些重复）" class="headerlink" title="二、类的加载过程（和上一点有些重复）"></a>二、类的加载过程（和上一点有些重复）</h2><ol><li>加载：根据查找路径找到相应的 class文件然后导入。</li><li>检查：检查加载的class 文件的正确性。</li><li>准备：给类中的静态变量和静态代码块分配内存。</li><li>解析：虚拟机将常量池中的符号引用换成直接引用。符号引用可以理解为一个标识，而直接引用直接指向内存中的地址。</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ol><h2 id="三、垃圾回收机制"><a href="#三、垃圾回收机制" class="headerlink" title="三、垃圾回收机制"></a>三、垃圾回收机制</h2><h3 id="1、如何确定某个对象是需要被回收的？"><a href="#1、如何确定某个对象是需要被回收的？" class="headerlink" title="1、如何确定某个对象是需要被回收的？"></a>1、如何确定某个对象是需要被回收的？</h3><p>JVM中主要有两种方法判定，一个是引用计数器，另一个是可达性分析。</p><p><strong>引用计数器：</strong>为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数器-1，当引用计数器为0是就可以回收。但是这个方法的缺点是不能解决循环引用的问题。</p><p><strong>可达性分析：</strong>这个方法是通过一系列的“GC Roots”对象作为起点，从起点开始往下搜索，搜索过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是可以回收的。不过这个对象至少要经历两次标记过程才会真的变成可回收对象。</p><h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><p>主要有以下四种垃圾回收算法，</p><h4 id="2-1-标记-清除算法（Mark-Sweep）"><a href="#2-1-标记-清除算法（Mark-Sweep）" class="headerlink" title="2.1 标记-清除算法（Mark-Sweep）"></a>2.1 标记-清除算法（Mark-Sweep）</h4><p>这是最基础的垃圾回收算法，最简单也最容易实现。主要分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占空间。标记-清除算法的缺点就是回收之后的的内存区域比较分散，不连续。</p><p>回收之前：</p><p><img src="https://i.loli.net/2020/11/24/pKHRyu2iWCbegds.png" alt="标记清除"></p><p>回收之后：</p><p><img src="https://i.loli.net/2020/11/24/dqhnBj679fcpwoJ.png" alt="标记清除"></p><h4 id="2-2-复制算法（Copying）"><a href="#2-2-复制算法（Copying）" class="headerlink" title="2.2 复制算法（Copying）"></a>2.2 复制算法（Copying）</h4><p>为了解决标记-清除算法的缺陷，出现了复制算法，它将可用内存an容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就讲还存活的对象复制到另一块上，然后再把当前这块使用的内存一次清理回收，这样就不会出现内存碎片的问题了。但是复制算法的缺点在于内存移动消耗太大。</p><p>回收之前：</p><p><img src="https://i.loli.net/2020/11/24/OD1sL5a9khYWTHx.png" alt="img"></p><p>回收之后：</p><p><img src="https://i.loli.net/2020/11/24/nUiAWTq3tEdyeGV.png" alt="img"></p><h4 id="2-3-标记-整理算法（Mark-Compact）"><a href="#2-3-标记-整理算法（Mark-Compact）" class="headerlink" title="2.3 标记-整理算法（Mark-Compact）"></a>2.3 标记-整理算法（Mark-Compact）</h4><p>为了解决复制算法的问题，提出了标记整理算法。它也是分为两个阶段，第一个阶段是标记，但是在标记完之后不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理边界以外的内存。</p><p>回收之前：</p><p><img src="https://i.loli.net/2020/11/24/lxdEhkTMJrDvVF5.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>回收之后：</p><p><img src="https://i.loli.net/2020/11/24/S2AOyRHvK8sVr6P.png" alt="img"></p><h4 id="2-4-分代收集（Generational-Collection）"><a href="#2-4-分代收集（Generational-Collection）" class="headerlink" title="2.4 分代收集（Generational Collection）"></a>2.4 分代收集（Generational Collection）</h4><p>分代收集是目前大部分JVM的垃圾回收器采用的算法。它是根据对象的生命周期不同划分为若干个不同的区域，一般分为老生代和新生代，老生代每次只有少量对象被回收，新生代则有大量对象被回收。这样就可以根据不同代的特点采取最合适的收集算法。新生代一般用复制算法，新生代又分为Eden区域和 from survivor、以及to survivor区域，他们默认占比是8:1:1，每次垃圾回收时，</p><ol><li>把Eden和from survivor中存活的对象放入 to survivor区；</li><li>清空Eden和from survivor区；</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li></ol><p>每次在from survivor 到 to survivor移动时都存活的对象，年龄就+1，当年龄达到15（默认值），就升级为老生代。大对象会直接进入老生代。</p><p>老生代当空间占用达到某个值之后就会触发全局垃圾回收，一般使用标记-整理算法，以上循环往复。</p><h3 id="3-典型的垃圾回收器"><a href="#3-典型的垃圾回收器" class="headerlink" title="3.典型的垃圾回收器"></a>3.典型的垃圾回收器</h3><h4 id="3-1-Serial-Serial-Old"><a href="#3-1-Serial-Serial-Old" class="headerlink" title="3.1 Serial/Serial Old"></a>3.1 Serial/Serial Old</h4><p>Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。</p><h4 id="3-2-ParNew"><a href="#3-2-ParNew" class="headerlink" title="3.2 ParNew"></a>3.2 ParNew</h4><p>ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。</p><h4 id="3-3-Parallel-Scavenge"><a href="#3-3-Parallel-Scavenge" class="headerlink" title="3.3 Parallel Scavenge"></a>3.3 Parallel Scavenge</h4><p>Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。</p><h4 id="3-4-Parallel-Old"><a href="#3-4-Parallel-Old" class="headerlink" title="3.4 Parallel Old"></a>3.4 Parallel Old</h4><p>Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。</p><h4 id="3-5-CMS"><a href="#3-5-CMS" class="headerlink" title="3.5 CMS"></a>3.5 CMS</h4><p>CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。</p><h4 id="3-6-G1"><a href="#3-6-G1" class="headerlink" title="3.6 G1"></a>3.6 G1</h4><p>G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。</p><p>四、运行时数据区</p><p>五、JVM调优</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10连接wsl2子系统ubuntu18.04图形界面</title>
    <link href="/2020/11/23/win10%E8%BF%9E%E6%8E%A5wsl2%E5%AD%90%E7%B3%BB%E7%BB%9Fubuntu18.04%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/"/>
    <url>/2020/11/23/win10%E8%BF%9E%E6%8E%A5wsl2%E5%AD%90%E7%B3%BB%E7%BB%9Fubuntu18.04%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="win10连接wsl2子系统ubuntu18-04图形界面"><a href="#win10连接wsl2子系统ubuntu18-04图形界面" class="headerlink" title="win10连接wsl2子系统ubuntu18.04图形界面"></a>win10连接wsl2子系统ubuntu18.04图形界面</h1><p>网上很多教程很多是用的 xfce4 和 VcXsrv ，虽然也可以，但是本次想玩点花的，所以想用 gnome 加上win10自带的远程桌面程序来连接，我记得之前连服务器的时候就是用的win10自带的远程桌面程序，感觉也挺好用的，不知道为啥网上都是用 VcXsrv 。。。而且主要是感觉过程也不怎么简单，还要另外下远程连接的软件，下载的速度还贼慢。。。安装的整个过程也是相当曲折，一方面网上关于这方面的基本搜不到，我也只查了很多零零散散的博客和资料看了之后将各种方法拼凑了一下。</p><p>中途遇到一些坑，导致wsl直接启动不了，重装也无济于事。。。索性最后成功了。为了以后不再踩同样的坑，在这里记录一下。</p><h3 id="1、安装systemd"><a href="#1、安装systemd" class="headerlink" title="1、安装systemd"></a>1、安装systemd</h3><p>查的资料说 gnome 桌面是基于 systemd 的，但是目前(2020.11.23) WSL 还不自带 systemd ，反正还有点问题吧，然后就只能我们自己安装，这里就是第一个坑，也就是<strong>导致 WSL 进不去的原因</strong>。</p><p>首先，我们在安装systemd之前一定要检查一下自己的WSL 系统有没有 <strong>daemonize</strong>  ，没有的话需要提前安装，不然之后安装了systemd会导致进不去WSL：</p><p><img src="https://i.loli.net/2020/11/23/2YjG4zlu8SmJvyq.png" alt="没装dasmonize"></p><p>查看有没有 <strong>daemonize</strong>：</p><pre><code class="hljs java">which daemonize</code></pre><p>如果有的话会输出路径信息，例如：/usr/bin/daemonize</p><p>如果什么都没有输出的话就是没有了。可以用以下命令安装：</p><pre><code class="hljs java">sudo apt-get install daemonize</code></pre><p>装好之后，就可以继续安装systemd了。运行命令更新软件列表：</p><pre><code class="hljs java">sudo apt update</code></pre><p>然后需要安装git，安装过的可以不用：</p><pre><code class="hljs java">sudo apt install git</code></pre><p>下载<strong>systemd</strong>：</p><pre><code class="hljs java">git clone https:<span class="hljs-comment">//github.com/DamionGans/ubuntu-wsl2-systemd-script.git</span></code></pre><p>进入目录：</p><pre><code class="hljs java">cd ubuntu-wsl2-systemd-script/</code></pre><p>运行：</p><pre><code class="hljs java">bash ubuntu-wsl2-systemd-script.sh</code></pre><p>这就安装完成了，然后重启WSL子系统或者重启电脑。</p><h3 id="2、安装gnome桌面"><a href="#2、安装gnome桌面" class="headerlink" title="2、安装gnome桌面"></a>2、安装gnome桌面</h3><pre><code class="hljs java">sudo apt updatesudo apt install -y ubuntu-desktop</code></pre><p>安装好之后安装Xrdp：</p><pre><code class="hljs java">sudo apt install -y xrdpsudo systemctl status xrdp</code></pre><pre><code class="hljs java">sudo adduser xrdp ssl-certsudo systemctl restart xrdp</code></pre><p>看一下端口，一般默认是 3389 ：</p><pre><code class="hljs java">vim /etc/xrdp/xrdp.ini</code></pre><p>配置防火墙：</p><pre><code class="hljs java">sudo ufw allow <span class="hljs-number">3389</span></code></pre><p>马上就大功告成了！</p><h3 id="3、连接远程桌面"><a href="#3、连接远程桌面" class="headerlink" title="3、连接远程桌面"></a>3、连接远程桌面</h3><p>注意连接的时候一定要保持xrdp服务运行，重启wsl之后要打开一下。</p><p><img src="https://i.loli.net/2020/11/23/Hq93eRSKoNYWnQC.png" alt="win10远程桌面1"></p><p>输入wsl的账号密码：</p><p><img src="https://i.loli.net/2020/11/23/Q5R3EFJmTKZC4fi.png" alt="win10远程桌面连接登录"></p><p>进入桌面：</p><p><img src="https://i.loli.net/2020/11/23/pfKWLguNmi2YrtQ.png" alt="gnome桌面1"></p><p>大功告成啦！</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动手实操</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云服务器Ubuntu18.04安装jdk</title>
    <link href="/2020/11/18/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8Ubuntu18.04%E5%AE%89%E8%A3%85jdk/"/>
    <url>/2020/11/18/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8Ubuntu18.04%E5%AE%89%E8%A3%85jdk/</url>
    
    <content type="html"><![CDATA[<h1 id="云服务器Ubuntu18-04安装jdk"><a href="#云服务器Ubuntu18-04安装jdk" class="headerlink" title="云服务器Ubuntu18.04安装jdk"></a>云服务器Ubuntu18.04安装jdk</h1><p>linux安装java jdk有几种方式，这里讲下我用的方式。就是下载好jdk压缩包，然后解压包再添加好环境变量。</p><h3 id="1、下载压缩包"><a href="#1、下载压缩包" class="headerlink" title="1、下载压缩包"></a>1、下载压缩包</h3><p><a href="https://www.injdk.cn/">https://www.injdk.cn/</a></p><p>这个网址有java jdk 的oracle版和各个openjdk发行版。因为之前刚在windows 的子系统WSL Ubuntu18.04 上安装了jdk,所以我直接把之前下载到windows电脑上的文件上传到了服务器。</p><p>我在 user(自己的用户名)目录下新建了 jdk 文件夹。</p><pre><code class="hljs shell">mkdir jdk</code></pre><p>然后把文件放到 jdk 目录下</p><p><img src="https://gitee.com/ericw5200/image/raw/master/img/image-20201118171805737.png" alt="image-20201118171805737"></p><h3 id="2、然后解压文件"><a href="#2、然后解压文件" class="headerlink" title="2、然后解压文件"></a>2、然后解压文件</h3><pre><code class="hljs shell">tar -xzfv zulu8.48.0.53-ca-jdk8.0.265-linux_x64.tar.gz -C /home/ericw/jdk</code></pre><p>更改解压出来的文件夹名：</p><pre><code class="hljs shell">mv zulu8.48.0.53-ca-jdk8.0.265-linux_x64/ jdk8.0.265</code></pre><h3 id="3、配置环境变量"><a href="#3、配置环境变量" class="headerlink" title="3、配置环境变量"></a>3、配置环境变量</h3><p>打开文件:</p><pre><code class="hljs shell">sudo vim ~/.bashrc</code></pre><p>在最后添加：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">配置环境变量</span>export JAVA_HOME=/home/ericw/jdk/jdk8.0.265  ## 这里要注意目录要换成自己解压的jdk 目录export JRE_HOME=$&#123;JAVA_HOME&#125;/jre  export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</code></pre><p>然后保存退出：</p><pre><code class="hljs shell">:wq</code></pre><p>更新配置文件：</p><pre><code class="hljs shell">source ~/.bashrc</code></pre><p>全部完成，可以查看版本信息验证一下：</p><p><img src="https://gitee.com/ericw5200/image/raw/master/img/jdk%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90.png" alt="jdk安装完成"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>java</tag>
      
      <tag>云服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多态经典题</title>
    <link href="/2020/11/16/java%E5%A4%9A%E6%80%81%E7%BB%8F%E5%85%B8%E9%A2%98/"/>
    <url>/2020/11/16/java%E5%A4%9A%E6%80%81%E7%BB%8F%E5%85%B8%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Java多态经典题"><a href="#Java多态经典题" class="headerlink" title="Java多态经典题"></a>Java多态经典题</h1><p>​        之前看过几次多态的题，当时感觉搞清楚了，但是过一段时间感觉又模糊不确定了，所以记录一下，而且后来在项目中有涉及相关的内容，应该会有更深的体会。</p><p><strong>题目：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.经典多态案例;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDuoTai</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a1 = <span class="hljs-keyword">new</span> A();        A a2 = <span class="hljs-keyword">new</span> B();        B b = <span class="hljs-keyword">new</span> B();        C c = <span class="hljs-keyword">new</span> C();        D d = <span class="hljs-keyword">new</span> D();        System.out.println(<span class="hljs-string">&quot;1--&quot;</span> + a1.show(b) + <span class="hljs-string">&quot;  &quot;</span> + System.identityHashCode(a1));        <span class="hljs-comment">// 为什么会向上找</span>        System.out.println(<span class="hljs-string">&quot;2--&quot;</span> + a1.show(c));        System.out.println(<span class="hljs-string">&quot;3--&quot;</span> + a1.show(d));        System.out.println(<span class="hljs-string">&quot;4--&quot;</span> + a2.show(b) + <span class="hljs-string">&quot;  &quot;</span> + System.identityHashCode(a2));        <span class="hljs-comment">/**(想法1.0)</span><span class="hljs-comment">         多态情况下，a2为A类型的引用，指向B类对象，</span><span class="hljs-comment">         先在B类里找有无该方法，有。但是父类A中没有，于是不能直接用B类的该方法，按照前三个的逻辑先去A类中找，A类中有show(A obj)，但是A的子类B类中重写了show(A obj)，所以调用B类的该方法</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">/**(想法2.0)</span><span class="hljs-comment">         *多态情况下，a2为A类型的引用，指向B类对象，在A类中找有无该方法，没有，但是A类为B类父类，所以调 *用A类的show(A obj)方法，然后A类的子类B重写了show(A obj)方法，</span><span class="hljs-comment">         * 所以最终调用B类的show(A obj)方法</span><span class="hljs-comment">         * */</span>        <span class="hljs-comment">// 只有方法才有多态性！！！</span>        System.out.println(<span class="hljs-string">&quot;5--&quot;</span> + a2.show(c));        System.out.println(<span class="hljs-string">&quot;6--&quot;</span> + a2.show(d));        System.out.println(<span class="hljs-string">&quot;7--&quot;</span> + b.show(b));        System.out.println(<span class="hljs-string">&quot;8--&quot;</span> + b.show(c));                <span class="hljs-comment">// 这里因为B类继承A类，而A类有该方法，且没被B重写，所以B类中隐含有该方法。</span>        System.out.println(<span class="hljs-string">&quot;9--&quot;</span> + b.show(d));      &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">show</span><span class="hljs-params">(D obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;A and D&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">show</span><span class="hljs-params">(A obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;A and A&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">show</span><span class="hljs-params">(B obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;B and B&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">show</span><span class="hljs-params">(A obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;B and A&quot;</span>);    &#125;    <span class="hljs-comment">/*  子类B中包含了父类A的这两个方法，只是B类重写覆盖了show(A obj)</span><span class="hljs-comment">    public String show(D obj) &#123;</span><span class="hljs-comment">        return (&quot;A and D&quot;);</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    public String show(A obj) &#123;</span><span class="hljs-comment">        return (&quot;A and A&quot;);</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">     */</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> </span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> </span>&#123;&#125;</code></pre><p><strong>注意：</strong>对于a2的情况，也就是父类引用指向子类对象的，a2是无法调用A类中没有而B类中有的方法的。也就是对于子类独有的方法，这个父类引用是无法调用的。</p><p>运行结果：</p><blockquote><p>1–A and A  460141958<br>2–A and A<br>3–A and D<br>4–B and A  1163157884<br>5–B and A<br>6–A and D<br>7–B and B<br>8–B and B<br>9–A and D</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win10子系统迁移安装目录到非系统盘</title>
    <link href="/2020/11/13/win10%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BF%81%E7%A7%BB%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E5%88%B0%E9%9D%9E%E7%B3%BB%E7%BB%9F%E7%9B%98/"/>
    <url>/2020/11/13/win10%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BF%81%E7%A7%BB%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E5%88%B0%E9%9D%9E%E7%B3%BB%E7%BB%9F%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Win10子系统迁移安装目录到非系统盘"><a href="#Win10子系统迁移安装目录到非系统盘" class="headerlink" title="Win10子系统迁移安装目录到非系统盘"></a>Win10子系统迁移安装目录到非系统盘</h1><p>​        因为电脑C盘吃紧，但是win10默认从Microsoft安装的软件都是在C盘的，安装完wsl之后，还要更新软件安装新软件之类的，这又要占用C盘空间，于是想把WSL的安装位置迁移到非系统盘。</p><p>​        之前其实就做过一次，这次在另一台电脑上弄的时候，发现操作好像和之前不一样，网上的都是要下一个 LxRunOffline.exe 的软件来辅助转移。有点疑惑，不知道两个的目的是不是一样，或者两个的操作是不是一个意思，主要是一开始用LxRunOffline.exe迁移失败了，最后wsl拒绝访问。然后重新装了WSL，用第一次的方法操作成功。所以不是太清楚这两个具体有哪些区别，但是目的达到了，因为迁移之后WSL安装的软件就没有安装在C盘了。</p><h3 id="1、查看WSL分发版本"><a href="#1、查看WSL分发版本" class="headerlink" title="1、查看WSL分发版本"></a>1、查看WSL分发版本</h3><p>用管理员权限打开 Windows PowerShell ，输入命令：</p><pre><code class="hljs shell">wsl -l --all -v</code></pre><p>显示如下：</p><pre><code class="hljs shell">NAMESTATEVERSIONUbuntu18.04 Runing 2</code></pre><h3 id="2、导出分发版为tar文件到D盘"><a href="#2、导出分发版为tar文件到D盘" class="headerlink" title="2、导出分发版为tar文件到D盘"></a>2、导出分发版为<strong>tar</strong>文件到D盘</h3><pre><code class="hljs shell">wsl --export Ubuntu-18.04 d:\wsl-ubuntu18.04.tar   #看清楚版本</code></pre><h3 id="3、注销当前分发版"><a href="#3、注销当前分发版" class="headerlink" title="3、注销当前分发版"></a>3、注销当前分发版</h3><pre><code class="hljs shell">wsl --unregister Ubuntu-18.04</code></pre><h3 id="4、重新导入并安装WSL到新的目录下"><a href="#4、重新导入并安装WSL到新的目录下" class="headerlink" title="4、重新导入并安装WSL到新的目录下"></a>4、重新导入并安装WSL到新的目录下</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 前面是新目录路径，后面是导出的tar文件的路径</span>wsl --import Ubuntu-18.04 d:\wsl-ubuntu18.04 d:\wsl-ubuntu18.04.tar --version 2</code></pre><h3 id="5、设置默认登陆用户为安装时用户名"><a href="#5、设置默认登陆用户为安装时用户名" class="headerlink" title="5、设置默认登陆用户为安装时用户名"></a>5、设置默认登陆用户为安装时用户名</h3><pre><code class="hljs shell">ubuntu1804 config --default-user Username#注意前面的版本号，最后Username写自己的用户名</code></pre><h3 id="6、删除tar文件（可选）"><a href="#6、删除tar文件（可选）" class="headerlink" title="6、删除tar文件（可选）"></a>6、删除tar文件（可选）</h3><pre><code class="hljs shell">del d:\wsl-ubuntu18.04.tar</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术干货</tag>
      
      <tag>小知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 18.04 添加新用户</title>
    <link href="/2020/11/12/Ubuntu18.04%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B7/"/>
    <url>/2020/11/12/Ubuntu18.04%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-18-04-添加新用户"><a href="#Ubuntu-18-04-添加新用户" class="headerlink" title="Ubuntu 18.04 添加新用户"></a>Ubuntu 18.04 添加新用户</h1><p>太久没用Linux,每次这些基本的命令都要重新百度找，这里做个记录，方便以后查找。</p><h2 id="1、创建用户"><a href="#1、创建用户" class="headerlink" title="1、创建用户"></a>1、创建用户</h2><p><strong>命令：</strong></p><p>adduer和useradd，对应着两条删除用户的命令：deluser和userdel</p><p>两者的区别：</p><p><strong>adduser:</strong> 会自动为创建的用户指定 <strong>主目录</strong>、<strong>系统shell版本</strong>，而且会在创建时输入<strong>用户密码</strong>。</p><p><strong>useradd:</strong> 需要使用参数手动指定上述的基本设置，如果不使用任何参数，则创建的用户没有密码、主目录，并且没有指定shell版本。</p><h3 id="1-1-adduser"><a href="#1-1-adduser" class="headerlink" title="1.1 adduser"></a>1.1 adduser</h3><p>输入命令：</p><pre><code class="hljs shell">sudo adduser tt</code></pre><p>输出显示：</p><pre><code class="hljs shell">[sudo] password for mqk: 正在添加用户&quot;tt&quot;...正在添加新组&quot;tt&quot; (1006)...正在添加新用户&quot;tt&quot; (1006) 到组&quot;tt&quot;...创建主目录&quot;/home/tt&quot;...正在从&quot;/etc/skel&quot;复制文件...输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：已成功更新密码正在改变 tt 的用户信息请输入新值，或直接敲回车键以使用默认值    全名 []:     房间号码 []:     工作电话 []:     家庭电话 []:     其它 []: 这些信息是否正确？ [Y/n] y</code></pre><p>这样在创建用户名时，就创建了用户的主目录以及密码。</p><p>默认情况下：<br>adduser在创建用户时会主动调用 /etc/adduser.conf；<br>在创建用户主目录时默认在/home下，而且创建为 /home/用户名</p><p>如果主目录已经存在，就不再创建，但是此主目录虽然作为新用户的主目录，而且默认登录时会进入这个目录下，但是这个目录并不是属于新用户，当使用userdel删除新用户时，并不会删除这个主目录，因为这个主目录在创建前已经存在且并不属于这个用户。</p><p>为用户指定shell版本为：/bin/bash<br>因此常用参数选项为：</p><ol><li>–home： 指定创建主目录的路径，默认是在/home目录下创建用户名同名的目录，这里可以指定；如果主目录同名目录存在，则不再创建，仅在登录时进入主目录。</li><li>–quiet： 即只打印警告和错误信息，忽略其他信息。</li><li>–debug： 定位错误信息。</li><li>–conf： 在创建用户时使用指定的configuration文件。</li><li>–force-badname： 默认在创建用户时会进行/etc/adduser.conf中的正则表达式检查用户名是否合法，如果想使用弱检查，则使用这个选项，如果不想检查，可以将/etc/adduser.conf中相关选项屏蔽。</li></ol><p><img src="https://source.acexy.cn/view/XW7p4uI"></p><h3 id="1-2-useradd"><a href="#1-2-useradd" class="headerlink" title="1.2 useradd"></a>1.2 useradd</h3><p>一般不怎么用这个，用到了再补。</p><h2 id="2、删除用户"><a href="#2、删除用户" class="headerlink" title="2、删除用户"></a>2、删除用户</h2><h3 id="2-1、deluser"><a href="#2-1、deluser" class="headerlink" title="2.1、deluser"></a>2.1、deluser</h3><p>只删除用户：</p><pre><code class="hljs she">sudo deluser tt</code></pre><p>输出显示：</p><pre><code class="hljs shel">正在删除用户 &#39;tt&#39;...警告：组&quot;tt&quot;没有其他成员了。完成。</code></pre><p>连同用户的主目录和邮箱一起删除：</p><pre><code class="hljs she">sudo deluser --remove-home tt</code></pre><p>输出显示：</p><pre><code class="hljs she">正在寻找要备份或删除的文件...正在删除文件...正在删除用户 &#39;tt&#39;...警告：组&quot;tt&quot;没有其他成员了。完成。</code></pre><p>连同用户拥有的所有文件删除：</p><pre><code class="hljs she">sudo deluser --remove-all-files tt</code></pre><p>相关文件：</p><pre><code class="hljs she">&#x2F;etc&#x2F;passwd - 使 用 者 帐 号 资 讯，可以查看用户信息&#x2F;etc&#x2F;shadow - 使 用 者 帐 号 资 讯 加 密&#x2F;etc&#x2F;group - 群 组 资 讯&#x2F;etc&#x2F;default&#x2F;useradd - 定 义 资 讯&#x2F;etc&#x2F;login.defs - 系 统 广 义 设 定&#x2F;etc&#x2F;skel - 内 含 定 义 档 的 目 录</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术干货</tag>
      
      <tag>小知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitee码云部署hexo个人博客</title>
    <link href="/2020/06/26/gitee%E7%A0%81%E4%BA%91%E9%83%A8%E7%BD%B2hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/06/26/gitee%E7%A0%81%E4%BA%91%E9%83%A8%E7%BD%B2hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="gitee码云部署hexo个人博客"><a href="#gitee码云部署hexo个人博客" class="headerlink" title="gitee码云部署hexo个人博客"></a>gitee码云部署hexo个人博客</h1><p>因为之前是把hexo博客部署在github上，但是国内这访问速度属实着急，于是这次改为gitee，速度比github不知道快了多少，用最近的话说就是如丝般顺滑！</p><a id="more"></a><p>这篇主要是讲怎么把github的博客迁移到gitee上，具体的搭建博客过程这里并不涉及，之后也可能整合起来写一下。<br>废话不多说，直接开始。</p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术干货</tag>
      
      <tag>采坑日记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派4b-USB启动</title>
    <link href="/2020/06/25/%E6%A0%91%E8%8E%93%E6%B4%BE4b-USB%E5%90%AF%E5%8A%A8/"/>
    <url>/2020/06/25/%E6%A0%91%E8%8E%93%E6%B4%BE4b-USB%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>新买了树莓派4b,看网上说可以用USB启动，就试了一下，还可以。</p><hr><p>这里是正文</p>]]></content>
    
    
    <categories>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术干货</tag>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/06/16/hello-world/"/>
    <url>/2020/06/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
